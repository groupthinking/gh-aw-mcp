package mcp

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os/exec"
	"sync"
	"sync/atomic"
)

// Connection represents a connection to an MCP server via stdio
type Connection struct {
	cmd         *exec.Cmd
	stdin       *bufio.Writer
	stdout      *bufio.Scanner
	ctx         context.Context
	cancel      context.CancelFunc
	pendingReqs map[interface{}]chan *Response
	mu          sync.Mutex
	requestID   atomic.Int64
}

// NewConnection creates a new MCP connection by launching a process
func NewConnection(ctx context.Context, command string, args []string, env map[string]string) (*Connection, error) {
	ctx, cancel := context.WithCancel(ctx)

	cmd := exec.CommandContext(ctx, command, args...)

	// Set environment variables
	if len(env) > 0 {
		cmd.Env = append(cmd.Env, cmd.Environ()...)
		for k, v := range env {
			cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
		}
	}

	// Setup stdin/stdout pipes
	stdinPipe, err := cmd.StdinPipe()
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
	}

	stdoutPipe, err := cmd.StdoutPipe()
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
	}

	// Start the process
	if err := cmd.Start(); err != nil {
		cancel()
		return nil, fmt.Errorf("failed to start process: %w", err)
	}

	conn := &Connection{
		cmd:         cmd,
		stdin:       bufio.NewWriter(stdinPipe),
		stdout:      bufio.NewScanner(stdoutPipe),
		ctx:         ctx,
		cancel:      cancel,
		pendingReqs: make(map[interface{}]chan *Response),
	}

	// Start reading responses
	go conn.readLoop()

	log.Printf("Started MCP server: %s %v", command, args)
	return conn, nil
}

// SendRequest sends a JSON-RPC request and waits for the response
func (c *Connection) SendRequest(method string, params interface{}) (*Response, error) {
	// Generate unique request ID
	id := c.requestID.Add(1)

	// Marshal params
	var paramsJSON json.RawMessage
	if params != nil {
		var err error
		paramsJSON, err = json.Marshal(params)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal params: %w", err)
		}
	}

	// Create request
	req := &Request{
		JSONRPC: "2.0",
		ID:      id,
		Method:  method,
		Params:  paramsJSON,
	}

	// Create response channel
	respChan := make(chan *Response, 1)
	c.mu.Lock()
	c.pendingReqs[id] = respChan
	c.mu.Unlock()

	// Send request
	reqJSON, err := json.Marshal(req)
	if err != nil {
		c.mu.Lock()
		delete(c.pendingReqs, id)
		c.mu.Unlock()
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	c.mu.Lock()
	_, err = c.stdin.Write(append(reqJSON, '\n'))
	if err == nil {
		err = c.stdin.Flush()
	}
	c.mu.Unlock()

	if err != nil {
		c.mu.Lock()
		delete(c.pendingReqs, id)
		c.mu.Unlock()
		return nil, fmt.Errorf("failed to write request: %w", err)
	}

	// Wait for response
	select {
	case resp := <-respChan:
		return resp, nil
	case <-c.ctx.Done():
		return nil, fmt.Errorf("connection closed")
	}
}

// readLoop continuously reads responses from stdout
func (c *Connection) readLoop() {
	for c.stdout.Scan() {
		line := c.stdout.Bytes()

		var resp Response
		if err := json.Unmarshal(line, &resp); err != nil {
			log.Printf("Failed to unmarshal response: %v", err)
			continue
		}

		// Find pending request
		c.mu.Lock()
		respChan, ok := c.pendingReqs[resp.ID]
		if ok {
			delete(c.pendingReqs, resp.ID)
		}
		c.mu.Unlock()

		if ok {
			respChan <- &resp
		} else {
			log.Printf("Received response for unknown request ID: %v", resp.ID)
		}
	}

	if err := c.stdout.Err(); err != nil {
		log.Printf("Error reading stdout: %v", err)
	}
}

// Close closes the connection
func (c *Connection) Close() error {
	c.cancel()
	return c.cmd.Wait()
}
